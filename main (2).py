#vk-обучение 1 модуль от 1 до 10 заданий
#Задание 3 
низкий = int(вход()) 
высокий = int(вход()) 
между = Истина 
пока правда: 
    строка = ввод() 
    если не строка: 
        перерыв 
    если между: 
        между = низкий < int(линия) <= высокий 
распечатать (между) 
 
#Задание 4 
s= ввод() 
print(('a' в s или 'o' в s) и 'i' не в s и 'e' не в s) 
 
#Задание 5 
целое число = целое число (вход()) 
число с плавающей запятой = число с плавающей запятой (вход()) 
intg_pos = int(input()) 
print(f"{integ:0=+10}") 
print(f"{flot:#>10.2f}") 
res_current = (f"{(intg_pos):0>16b}") 
res_current = str(res_current) 
результат = ул (res_current) 
результат = (результат[::-1]) 
print('_'.join(result[i:i+4] for i in range(0, len(result),4))[::-1]) 
 
#Задача 6  
s = ввод() 
c1 = длина(ы) 
s = s.replace('!','') 
s = s.replace('@','') 
s = s.replace('#','') 
s = s.replace('%','') 
печать(c1 - длина(ы)) 
печать(s.lower()) 
 
#Задача 7 
s = ввод() 
п = с.сплит() 
с1 = длина (п) 
с2 = 0 
для _ в n: 
    с2 += длина(_) 
печать(c2/c1) 
 
#Задание 8  
n = целое число (вход()) 
макс_значения = [] 
для _ в диапазоне (n): 
    запись = ввод() 
    значения = запись.split() 
    значения = [int(значение) для значения в значениях] 
    max_value = максимум (значения) 
    max_values.append(max_value) 
max_values.sort(обратное=Истина) 
вывод = ';'.join(map(str, max_values)) 
печать (выход) 
 
#Задание 9 
input_string = input().lower() 
unique_chars = set(input_string) - {' '} 
print(' '.join(sorted(list(unique_chars)))) 
 
#Задание 10 
строка = ввод() 
слова = [] 
текущее_слово = "" 
для символа в строке: 
    если char.isalnum(): 
        текущее_слово += символ 
    Элиф текущее_слово: 
        слова.добавление(текущее_слово) 
        текущее_слово = "" 
если текущее_слово: 
    слова.добавление(текущее_слово) 
word_counts = {} 
за слово словами: 
    слово = слово.ниже() 
    если слово в word_counts: 
        word_counts[слово] += 1 
    еще: 
        word_counts[слово] = 1 
Most_common_word = "" 
Most_common_count = 0 
для слова подсчитайте в word_counts.items(): 
    если count >most_common_count: 
        Most_common_word = слово 
        Most_common_count = количество 
print(most_common_word,most_common_count)
#vk-обучение 2 модуль от 12 до 23 заданий
#12 
среднее значение (числа): 
    nums = [int(num) для числа в Numbers.split()] 
    вернуть сумму (числа)/длину (числа) 
 
пока правда: 
    последовательность = ввод() 
    если последовательность == "": 
        перерыв 
    печать(среднее(последовательность)) 
 
#13 
защитаprocess_string(input_str): 
    если input_str.startswith("!"): 
        обработанная_строка = входная_строка[1:].upper() 
    еще: 
        обработанная_строка = input_str.lower() 
 
    обработанная_строка = обработанная_строка.replace("!", "").replace("@", "").replace("#", "").replace("%", "") 
 
    вернуть обработанную_строку 
 
пока правда: 
    input_str = ввод() 
    если input_str == "": 
        перерыв 
    печать (process_string (input_str)) 
 
#14 
начало = 1 
конец = 10 
шаг = 2 
 
seq = диапазон (начало, конец, шаг)
результат = карта (лямбда x: x  2, если x % 2 != 0, иначе -x, seq) 
 
для разрешения в результате: 
    печать (рез) 
 
#15 
фиб_кэш = {} 
 
защита Фибоначчи (n): 
    если n в fib_cache: 
        вернуть fib_cache[n] 
 
    если n == 1 или n == 2: 
        результат = 1 
    еще: 
        результат = фибоначчи(n - 1) + фибоначчи(n - 2) 
 
    fib_cache[n] = результат 
    вернуть результат 
 
n = целое число (вход()) 
печать (фибоначчи (п)) 
 
#16 
Защиту Map_custom (функция, последовательность): 
    для элемента в последовательности: 
        функция доходности (элемент) 
func_in, seq_in = eval(input()), eval(input()) 
 
для x в map_custom(func_in, seq_in): 
    распечатать(х) 
 
#17 
Защиту filter_custom (функция, последовательность): 
    для элемента в последовательности: 
        если функция (элемент): 
            предмет доходности 
func_in, seq_in = eval(input()), eval(input()) 
 
для x в filter_custom(func_in, seq_in): 
    распечатать(х) 
 
#18 
защита кэш_деко (функция): 
    кэш = {} 
    защита-обертка (* аргументы): 
        если аргументы в кеше: 
            вернуть кеш[аргументы] 
        результат = func(*args) 
        кеш[args] = результат 
        вернуть результат 
    возвратная обертка 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
 
#19 
защита повторения_деко (n = 1): 
    декоратор защиты (функция): 
        def-обертка(*args, **kwargs): 
            результат = Нет 
            для _ в диапазоне (n): 
                результат = func(*args, **kwargs) 
            вернуть результат 
        возвратная обертка 
    вернуть декоратор 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
 
#20 
а = интервал (вход()) 
 
защита f(): 
    глобальный а 
    а += 10 
 
е() 
 
распечатать(а) 
 
#21 
от ввода списка импорта, Dict 
 
def make_most_common_keys(d: Dict[int, int]) -> List[int]: 
    return sorted(d, key=d.get,verse=True) 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
 
#22 
защита f(): 
    защита г(): 
        б = целое число (вход()) 
        защита ч(): 
            нелокальный б 
            б += 10 
        час() 
        распечатать(б) 
    г() 
е() 
 
#23 
от ввода списка импорта 
 
def get_indexes(nums1: List[int], nums2: List[int]) -> List[int]: 
    вернуть [i для i, (n1, n2) в enumerate(zip(nums1, nums2)) если n1 < n2] 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код)
#vk-education 3 модуль выполненные задания: 24, 25, 26, 27, 28 и 31
#24 
класс Счетчик: 
    Защиту init (сам, начальный_счет): 
        self.count = начальный_счет 
 
    приращение защиты (сам): 
        self.count += 1 
 
    защита get(self): 
        вернуть self.count 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
vk-обучение 3 модуль 
#25 
классный круг: 
    пи = 3,14 
 
    Защиту Calculate_area (я, радиус): 
        вернуть self.pi * (радиус  2) 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
 
#26 
Класс Человек: 
    def init(я, возраст): 
        self._age = возраст 
 
    @свойство 
    возраст определения (собственный): 
        вернуть self._age 
 
    @age.setter 
    def age(собственность, значение): 
        если значение < 0: 
            self._age = 0 
        еще: 
            self._age = значение 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
#27 
класс Маятник:     
    г = 10 
    пи = 3,14 
 
    @classmethod 
    Защиту вычислить_период (cls, длина):
вернуть 2 * cls.pi * (длина/cls.g)  0,5 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
#28 
классный круг: 
    _пи = 3,14 
 
    def init(сам, радиус): 
        self._radius = радиус 
 
    @свойство 
    радиус защиты (собственный): 
        вернуть self._radius 
 
    @свойство 
    защита пи(сам): 
        вернуть self._pi 
 
    защита вычислить_область (сам): 
        вернуть self._pi * self._radius  2 
 
 
класс SemiCircle(Круг): 
    защита вычислить_область (сам): 
        вернуть супер().calculate_area()/2 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
#31 
класс ContextDictionary: 
    определение инициализации (сам): 
        self.dictionary = Нет 
 
    Защитный вход (сам): 
        само.словарь = {} 
        вернуть себя 
 
    Защитный выход (сам, exc_type, exc_val, exc_tb): 
        self.dictionary = Нет 
 
    def put(self, key, value): 
        self.dictionary[ключ] = значение 
 
    def get(self, key): 
        вернуть self.dictionary[ключ] 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код)
#vk-education 4 модуль выполнил задние 33, 34, 36, 37, 39 и 40
#33 
импортировать ОС 
 
текст = ввод() 
 
защита write_and_read(текст): 
    file_path = os.path.join("/tmp", "temp_file.txt") 
 
    # Запись текста в файл 
    с open(file_path, «w») как файл: 
        file.write(текст) 
 
    # Читаем текст из файла 
    с open(file_path, «r») как файл: 
        text_from_file = file.read() 
 
    # Удаляем временный файл 
    os.remove(путь_файла) 
 
    вернуть текст_из_файла 
 
печать (write_and_read (текст)) 
#34 
числитель, знаменатель = int(input()), int(input()) 
 
def измененный_div(числитель, знаменатель): 
    пытаться: 
        результат = числитель/знаменатель 
    кроме ZeroDivisionError: 
        обратный знаменатель 
    еще: 
        вернуть знаменатель/результат 
 
print(changed_div(числитель, знаменатель)) 
#36 
из itertools импортировать zip_longest 
от ввода списка импорта, кортежа 
 
 
def fill_missing_values(values_list_1: List[int],values_list_2: List[int]) -> List[Tuple[int, int]]: 
    результат = [] 
    для val1, val2 в zip_longest(values_list_1,values_list_2, fillvalue=1): 
        result.append((значение1, значение2)) 
    вернуть результат 
 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
#37 
импорт даты и времени 
 
дни, секунды = int(input()), int(input()) 
 
defshift_time(дни: int, секунды: int): 
    base_time = datetime.datetime(2023, 1, 1, 12, 30, 0) 
    delta = datetime.timedelta(дни=дни, секунды=секунды) 
    сдвинутое_время = базовое_время + дельта 
    вернуть сдвиг_время.день, сдвиг_время.секунда 
 
print(shift_time(дни, секунды)) 
#39 
импорт даты и времени 
из коллекций Счетчик импорта 
от ввода списка импорта 
 
 
def Most_common_months(dates: List[str], n) -> List[int]: 
    месяцы = [int(date.split('-')[1]) для даты в датах] 
    Month_counts = Счетчик (месяцев) 
    Most_common =month_counts.most_common(n) 
    return [месяц за месяцем, _ в Most_common] 
 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
из коллекций импортировать дек 
от ввода списка импорта 
 
 
def Rotate_list(nums: List[int], n: int): 
    очередь = дек (числа) 
    n = n % len(очередь)   
        очередь.appendleft(queue.pop()) 
    список возврата (очередь) 
 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные) 
код = "\n".join(код) 
исполнительный (код) 
 
#40 
из коллекций импортировать дек 
от ввода списка импорта 
 
 
def Rotate_list(nums: List[int], n: int): 
    очередь = дек (числа) 
    n = n % len(queue) # Если n больше длины списка, беременеть остаток от деления 
    для _ в диапазоне (n): 
        очередь.appendleft(queue.pop()) 
    список возврата (очередь) 
 
 
код = [] 
в то время как данные:= ввод(): 
    code.append(данные)
код = "\n".join(код) 
исполнительный (код)